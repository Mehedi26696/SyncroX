\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{float}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning}
\usepackage{svg}
\usetikzlibrary{shadows}

% Define colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{ducolor}{rgb}{0.0,0.2,0.5}
\definecolor{primarycolor}{rgb}{0.0,0.2,0.5}
\definecolor{secondarycolor}{rgb}{0.0,0.4,0.7}
\definecolor{goldaccent}{rgb}{0.85,0.65,0.13}

\usepackage{listings}
\usepackage{xcolor}

\lstdefinelanguage{json}{
    basicstyle=\ttfamily\small,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    literate=
     *{0}{{{\color{blue}0}}}{1}
      {1}{{{\color{blue}1}}}{1}
      {2}{{{\color{blue}2}}}{1}
      {3}{{{\color{blue}3}}}{1}
      {4}{{{\color{blue}4}}}{1}
      {5}{{{\color{blue}5}}}{1}
      {6}{{{\color{blue}6}}}{1}
      {7}{{{\color{blue}7}}}{1}
      {8}{{{\color{blue}8}}}{1}
      {9}{{{\color{blue}9}}}{1}
      {:}{{{\color{red}:}}}{1}
      {,}{{{\color{red},}}}{1}
      {\{}{{{\color{black}{\{}}}}{1}
      {\}}{{{\color{black}{\}}}}}{1}
}


% Listings configuration
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Hyperref configuration
\hypersetup{
    colorlinks=true,
    linkcolor=ducolor,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={SyncroX - Networking Project Report},
    pdfauthor={H.M. Mehedi Hasan, MD. Abu Bakar Siddique},
    pdfpagemode=FullScreen,
}

% Section formatting
\titleformat{\section}
  {\normalfont\Large\bfseries\color{ducolor}}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{ducolor}}{\thesubsection}{1em}{}

\begin{document}

% ======================== COVER PAGE ========================
% Title Page
\begin{titlepage}
    \centering
    \vspace*{1cm}
    \includesvg[width=2.5cm]{du}

    {\Huge\bfseries University of Dhaka\par}
    \vspace{0.5cm}
    {\Large Department of Computer Science and Engineering\par}
    \vspace{1.2cm}
    
        % Project Type Badge
    \begin{tikzpicture}
        \node[rectangle, rounded corners=8pt, draw=goldaccent, line width=2pt, 
              fill=goldaccent!10, inner sep=8pt, drop shadow] {
            {\large\bfseries\color{primarycolor} NETWORKING PROJECT }
        };
    \end{tikzpicture}
    \vspace{0.5cm}
    
    {\color{secondarycolor}\LARGE\bfseries SyncroX\par}
    \vspace{0.3cm}
    {\Large A Unified Real-Time Collaboration \& Communication Platform\par}
    \vspace{0.5cm}
    
    {\large\bfseries Course: CSE 3111 - Computer Networking Lab\par}
    \vspace{0.3cm}
    
   \begin{center}
                    {\large\bfseries\color{primarycolor} Submitted By:}\\[0.4cm]
                    {\large H.M. Mehedi Hasan \textbf{(13)}}\\[0.3cm]
                    {\large MD. Abu Bakar Siddique \textbf{(47)}}\\
                    
                \end{center}
\vspace{0.4cm}




\begin{center}
    {\large\bfseries\color{primarycolor} Submitted To:}\\[0.4cm]
\end{center}

\begin{center}
    \textbf{Dr. Shabbir Ahmed} (Professor) \\
    Department of Computer Science and Engineering
    \vspace{0.2cm}
    
    \textbf{Dr. Md. Mamun-Or-Rashid} (Professor) \\
    Department of Computer Science and Engineering
    \vspace{0.2cm}
    
    \textbf{Dr. Ismat Rahman} (Associate Professor) \\
    Department of Computer Science and Engineering
    \vspace{0.2cm}
    
    \textbf{Palash Roy} (Lecturer) \\
    Department of Computer Science and Engineering
\end{center}


\vspace{0.2cm}

{\large \centering Submission Date: December 7, 2025\par}

    
\end{titlepage}

% ======================== TABLE OF CONTENTS ========================
\tableofcontents
\newpage

% ======================== OVERVIEW ========================
\section{Overview}

SyncroX is a comprehensive, production-grade collaborative platform designed to demonstrate advanced networking concepts including custom TCP protocol design, congestion control algorithms, RTT estimation, and secure sandboxed code execution. Built entirely with Python, Streamlit, and Docker, SyncroX provides a robust environment for real-time teamwork and experimentation in computer networking.

The platform unifies multiple collaboration tools into a single cohesive system, offering:
\begin{itemize}
    \item Real-time chat with room-based messaging
    \item Collaborative code editing with live synchronization
    \item File sharing with congestion control (Tahoe/Reno algorithms)
    \item Secure code execution in Docker containers
    \item Real-time dashboard for network metrics visualization
\end{itemize}

SyncroX serves as both an educational tool for understanding networking principles and a practical application showcasing real-world distributed system design.

% ======================== MOTIVATION ========================
\section{Motivation}

The motivation behind SyncroX stems from several key observations in modern collaborative work and computer networking education:

\subsection{Educational Gap}
Traditional networking courses often focus on theoretical concepts without sufficient hands-on implementation. SyncroX bridges this gap by providing a complete, working implementation of:
\begin{itemize}
    \item Custom TCP protocol design
    \item Flow control mechanisms
    \item Congestion control algorithms (Tahoe and Reno)
    \item Round-Trip Time (RTT) estimation
    \item Multi-threaded server architectures
\end{itemize}

\subsection{Practical Application}
Remote collaboration has become essential in modern workflows. SyncroX addresses the need for an integrated platform that combines:
\begin{itemize}
    \item Instant communication (chat)
    \item Collaborative development (code editor)
    \item Resource sharing (file transfer)
    \item Code execution and testing
\end{itemize}


% ======================== PROBLEM STATEMENT ========================
\section{Problem Statement}

In modern software development and academic environments, teams face significant challenges with fragmented collaboration workflows. Students and developers typically juggle multiple disconnected tools:

\begin{itemize}
    \item \textbf{Communication Silos}: Separate chat applications (WhatsApp, Discord) for discussions
    \item \textbf{Code Sharing Friction}: Email attachments, USB drives, or manual copy-paste for code exchange
    \item \textbf{File Transfer Overhead}: Cloud storage services with upload/download delays
    \item \textbf{Execution Environment Mismatch}: "It works on my machine" syndrome due to different setups
    \item \textbf{Lack of Real-time Feedback}: No visibility into network performance during transfers
\end{itemize}

\subsection{Core Problems Addressed}

\textbf{P1: Tool Fragmentation}

Teams waste time switching between applications, leading to context loss and reduced productivity. There is no single platform that integrates chat, file transfer, code editing, and execution.

\textbf{P2: Educational Gap in Networking}

Networking courses teach theoretical concepts (congestion control, RTT estimation, protocol design) but lack hands-on implementation projects that demonstrate these principles in action.

\textbf{P3: Unsafe Code Execution}

Sharing and running untested code poses security risks. Without proper sandboxing, malicious or buggy code can compromise systems.

\textbf{P4: No Network Performance Visibility}

Existing file transfer tools (FTP, SFTP) don't provide real-time insights into congestion control mechanisms, making it difficult to understand networking behavior.

\subsection{Solution Approach}

SyncroX addresses these problems by:

\begin{itemize}
    \item Building a unified platform with chat, code editor, file transfer, and execution
    \item Implementing custom TCP protocols to demonstrate networking concepts
    \item Providing Docker-based sandboxing for secure code execution
    \item Visualizing real-time metrics (RTT, CWND, throughput) during file transfers
    \item Offering room-based isolation for team privacy
\end{itemize}

% ======================== DESIGN GOALS/OBJECTIVES ========================
\section{Design Goals/Objectives}

\subsection{Primary Objectives}

\begin{enumerate}
    \item \textbf{Demonstrate Advanced Networking Concepts}
    \begin{itemize}
        \item Implement custom TCP protocols for different services
        \item Apply Tahoe and Reno congestion control algorithms
        \item Measure and visualize RTT and network performance metrics
        \item Implement flow control and rate limiting mechanisms
    \end{itemize}
    
    \item \textbf{Ensure Security and Isolation}
    \begin{itemize}
        \item Docker-based sandboxing for code execution
        \item Resource limits (256MB RAM, 0.5 CPU cores)
        \item Network isolation for running code
        \item 10-second execution timeout
    \end{itemize}
    
    \item \textbf{Provide Real-time Collaboration}
    \begin{itemize}
        \item Live code synchronization across multiple users
        \item Instant message broadcasting
        \item Real-time file transfer progress
        \item Active user presence tracking
    \end{itemize}
    
    \item \textbf{Build Modular and Scalable Architecture}
    \begin{itemize}
        \item Independent TCP servers for each service
        \item Thread-safe concurrent client handling
        \item Room-based resource isolation
        \item Clean separation of frontend and backend
    \end{itemize}
\end{enumerate}


% ======================== PROJECT FEATURES ========================
\section{Project Features}

\subsection{1. Real-Time Chat System}

\textbf{Key Features:}
\begin{itemize}
    \item Room-based instant messaging with 4-digit room codes
    \item Rate limiting: maximum 5 messages per 2 seconds per user
    \item User presence tracking and notifications
    \item \textbf{Persistent message history} stored in JSON format
    \item Support for text messages, emojis, and images
    \item \textbf{Image CDN}: Server-side image storage with base64 encoding
    \item Message ID and timestamp tracking
    \item System notifications (user join/leave)
    \item History retrieval with configurable limits (up to 200 messages)
\end{itemize}

\textbf{Technical Implementation:}
\begin{itemize}
    \item TCP server on port 9009
    \item Multi-threaded architecture for concurrent connections
    \item Persistent storage: \texttt{data/chat\_history/room\_<room>\_chat.json}
    \item Image storage: \texttt{data/cdn/} directory
    \item UTF-8 encoding for international character support
    \item Integration with Room Management Service (Port 9013)
\end{itemize}

\subsection{2. Collaborative Code Editor}

\textbf{Key Features:}
\begin{itemize}
    \item Live code synchronization across multiple users
    \item Multi-language support: Python, C, C++, Java
    \item Syntax highlighting in the frontend
    \item Active user indicators showing who is editing
    \item Auto-save every 2 seconds
    \item Last-write-wins conflict resolution
\end{itemize}

\textbf{Technical Implementation:}
\begin{itemize}
    \item TCP server on port 9011
    \item Persistent storage in \texttt{data/collab\_docs/}
    \item Document versioning with editor metadata
    \item Thread-safe read/write operations
    \item Background synchronization thread in frontend
\end{itemize}

\subsection{3. File Transfer System}

\textbf{Key Features:}
\begin{itemize}
    \item Secure file upload/download per room
    \item \textbf{Hybrid Protocol Design}:
    \begin{itemize}
        \item TCP for control signaling and file listing (Port 9010)
        \item Custom Reliable UDP for both high-speed uploads and downloads (Port 9011)
    \end{itemize}
    \item \textbf{Reliable UDP Implementation}:
    \begin{itemize}
        \item 3-way handshake (SYN, SYN-ACK, ACK) for connection establishment
        \item 4-way termination (FIN, FIN-ACK) for graceful shutdown
        \item Cumulative ACKs for efficiency
        \item Sliding window with in-flight packet management
        \item Sequence number tracking for packet ordering
    \end{itemize}
    \item Configurable congestion control (Tahoe or Reno)
    \item Per-chunk RTT measurement and visualization
    \item 4KB chunk size with individual ACKs
    \item Binary-safe transfers with base64 encoding
    \item File metadata (size, timestamp)
    \item Session-based transfer tracking with UUIDs
\end{itemize}

\textbf{Congestion Control Implementation:}
\begin{itemize}
    \item \textbf{Tahoe}: Slow start, congestion avoidance, reset to CWND=1 on loss
    \item \textbf{Reno}: Includes fast recovery (CWND = ssthresh on loss)
    \item Real-time metrics logging to CSV
    \item Dynamic window size adjustment
    \item Receiver window (RWND) management
\end{itemize}

\subsection{4. Code Execution Engine}

\textbf{Key Features:}
\begin{itemize}
    \item Sandboxed Docker execution environment
    \item Support for Python, C, C++, and Java
    \item Resource limits: 256MB RAM, 0.5 CPU cores
    \item \textbf{Language-specific timeouts}:
    \begin{itemize}
        \item Python: 3 seconds
        \item C/C++ compilation: 5 seconds
        \item C/C++ execution: 3 seconds
        \item Java compilation: 15 seconds (javac is slow)
        \item Java execution: 10 seconds (JVM startup overhead)
    \end{itemize}
    \item Full stdin/stdout/stderr handling
    \item Compilation support for C/C++/Java
    \item Automatic Java class name extraction
    \item Execution history tracking per room
\end{itemize}

\textbf{Security Measures:}
\begin{itemize}
    \item Isolated Docker containers per execution
    \item Non-root user execution (runner user)
    \item Automatic container cleanup
    \item Resource monitoring and limits
\end{itemize}

\subsection{5. System Dashboard}

\textbf{Key Features:}
\begin{itemize}
    \item Real-time server status monitoring
    \item Active room and user count
    \item RTT and congestion window visualization
    \item File transfer metrics (graphs and charts)
    \item Network performance analytics
    \item Historical data visualization
\end{itemize}

% ======================== BLOCK DIAGRAM/WORKFLOW ========================
\section{Block Diagram/Work Flow Diagram}

\subsection{System Architecture}

The system follows a client-server architecture with five independent TCP servers and a dedicated UDP service for file transfer:
\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{workflow.png}
    \caption{SyncroX System Architecture Workflow}
\end{figure}



\subsection{Communication Flow}

\begin{enumerate}
    \item \textbf{User Authentication}: User enters name and creates/joins a room
    \item \textbf{Service Selection}: User navigates to Chat, Editor, Files, or Dashboard
    \item \textbf{TCP Connection}: Frontend establishes connection to appropriate server
    \item \textbf{Data Exchange}: Custom protocol commands exchanged over TCP
    \item \textbf{Real-time Updates}: Background threads poll for changes
    \item \textbf{Response Handling}: Frontend updates UI based on server responses
\end{enumerate}



% ======================== TOOLS \& TECHNOLOGIES ========================
\section{Tools \& Technologies}

\subsection{Programming Languages}
\begin{itemize}
    \item \textbf{Python 3.10+}: Core language for all components
    \item \textbf{C/C++}: Supported execution languages
    \item \textbf{Java}: Supported execution language
\end{itemize}

\subsection{Frontend Technologies}
\begin{itemize}
    \item \textbf{Streamlit 1.36.0}: Web framework for UI
    \item \textbf{Pandas}: Data processing and metrics
    \item \textbf{Matplotlib}: Chart and graph visualization
    \item \textbf{streamlit-autorefresh}: Real-time UI updates
    \item \textbf{Custom CSS}: Dark theme styling
\end{itemize}

\subsection{Backend Technologies}
\begin{itemize}
    \item \textbf{Socket Programming}: Pure Python TCP servers
    \item \textbf{Threading}: Concurrent client connections
    \item \textbf{Pathlib}: File system operations
    \item \textbf{Collections}: Data structures (defaultdict, deque)
\end{itemize}

\subsection{Infrastructure}
\begin{itemize}
    \item \textbf{Docker}: Containerization and sandboxing
    \item \textbf{python:3.12-slim}: Base Docker image for sandbox
    \item \textbf{GCC/G++}: C/C++ compilation in sandbox
    \item \textbf{OpenJDK (default-jdk)}: Java compilation and execution
    \item \textbf{Custom Image}: \texttt{syncrox-sandbox} with all compilers pre-installed
    \item \textbf{Non-root Execution}: Sandbox uses \texttt{runner} user for security
\end{itemize}


% ======================== APPLIED NETWORKING CONCEPTS ========================
\section{Applied Networking Concepts}

\subsection{Custom TCP Protocol Design}

Each service implements a custom application-layer protocol over TCP:

\subsubsection{Chat Protocol (Port 9009)}
\begin{lstlisting}[language=bash, caption=Chat Server Commands]
HELLO <username>         -> OK Hello <username>
JOIN_ROOM <code>         -> OK Joined <code>
MSG <text>               -> Broadcast to room
IMG_SEND <base64>        -> Broadcast image
LIST_ROOMS               -> ROOMS <count> <room1> <room2>...
BYE                      -> OK Bye
\end{lstlisting}

\subsubsection{File Transfer Protocol (Ports 9010/9011)}

\textbf{TCP Operations (Port 9010):}
\begin{lstlisting}[language=bash, caption=TCP File Commands]
LIST <room>                      -> FILES <count> + file list
DOWNLOAD <room> <filename>       -> OK <size> + binary data
BYE                              -> OK Bye
\end{lstlisting}

\textbf{UDP Operations (Port 9011) - Reliable File Transfer (Upload \& Download):}
\begin{lstlisting}[language=bash, caption=Reliable UDP Protocol]
# Connection Establishment (3-way handshake)
Client: SYN {room, filename}
Server: SYN-ACK {session_id}
Client: ACK {session_id}

# Data Transfer
Client: DATA {session_id, seq, total, payload_b64}
Server: ACK {session_id, ack_seq, rwnd}

# Connection Termination (4-way)
Server: FIN {session_id, filename}
Client: FIN-ACK {session_id}
\end{lstlisting}

\textbf{Packet Structure (JSON Schema):}
To ensure interoperability and ease of debugging, all UDP packets use a strict JSON schema:

\begin{lstlisting}[language=json, caption=UDP Data Packet Structure]
{
  "type": "DATA",
  "room": "1234",
  "filename": "lab_report.pdf",
  "seq": 105,
  "total": 500,
  "session_id": "a1b2c3d4",
  "payload_b64": "JVBERi0xLjcKCjEgMCBvYmo..."
}
\end{lstlisting}

\textbf{Flow Control Mathematics:}
We implemented receiver-side flow control using a variable Receive Window (\texttt{rwnd}) to prevent buffer overflow. The \texttt{rwnd} is calculated dynamically and advertised in every ACK packet:

\begin{equation}
RWND = \text{Max\_Buffer\_Size} - \text{Out\_Of\_Order\_Count}
\end{equation}

When the receiver buffer fills up (i.e., $RWND \rightarrow 0$), the sender pauses transmission until space becomes available, effectively implementing backpressure.

\textbf{Connection State Machine:}
The Reliable UDP protocol follows a strict state machine for session management:

\begin{itemize}
    \item \texttt{LISTEN}: Server waiting for SYN.
    \item \texttt{SYN\_RCVD}: Server received SYN, sent SYN-ACK.
    \item \texttt{ESTABLISHED}: Handshake complete, data transfer in progress.
    \item \texttt{FIN\_WAIT}: Transfer complete, waiting for termination Acks.
    \item \texttt{CLOSED}: Session cleaned up.
\end{itemize}

\textbf{Reliability Features:}
\begin{itemize}
    \item \textbf{Cumulative ACKs}: Server ACKs highest in-order packet received
    \item \textbf{Sliding Window}: Multiple packets in flight (limited by CWND and RWND)
    \item \textbf{Sequence Tracking}: Each chunk numbered sequentially
    \item \textbf{Out-of-order Buffering}: Receiver buffers future packets
    \item \textbf{Session Management}: UUID-based session tracking
    \item \textbf{Retransmission}: Timeout-based and fast retransmit (3 dup ACKs)
\end{itemize}

\subsubsection{Collaboration Protocol (Port 9011)}
\begin{lstlisting}[language=bash, caption=Collaboration Server Commands]
HELLO <username>         -> OK Hello <username>
JOIN <room> <lang>       -> OK Joined <room>
                         -> DOC <room> <lang> <size> <editor>
                         + <code_bytes>
SET <room> <lang> <size> -> OK SAVED (broadcasts to all)
  + <code_bytes>         -> DOC <room> <lang> <size> <editor>
GET <room> <lang>        -> DOC <room> <lang> <size> <editor>
                         + <code_bytes>
USERS <room>             -> USERS <room> <user1:status>,...
BYE                      -> OK Bye
\end{lstlisting}

\textbf{Key Features:}
\begin{itemize}
    \item \textbf{Language-specific documents}: Each room can have separate documents for Python, C, C++, Java
    \item \textbf{Persistent storage}: Documents saved to \texttt{data/collab\_docs/<room>\_<lang>.txt}
    \item \textbf{Last-write-wins}: Simple conflict resolution with editor attribution
    \item \textbf{Broadcast synchronization}: All room members notified of changes instantly
\end{itemize}

\subsubsection{Code Execution Protocol (Port 9012)}
\begin{lstlisting}[language=bash, caption=Code Execution Commands]
EXECUTE <room> <lang> <code_size> <stdin_size>
  + <code_bytes> + <stdin_bytes>
  -> RESULT <success> <rc> <stdout_size> <stderr_size> <time_ms>
  + <stdout_bytes> + <stderr_bytes>
BYE                      -> OK Bye
\end{lstlisting}

\subsubsection{Room Management Protocol (Port 9013)}
\begin{lstlisting}[language=bash, caption=Room Management Commands]
CREATE <username>        -> ROOM <code>
EXISTS <code>            -> EXISTS true/false
LIST                     -> ROOMS <count> <code1> <code2>...
\end{lstlisting}

\textbf{Key Features:}
\begin{itemize}
    \item \textbf{Centralized Room Registry}: Single source of truth for room existence
    \item \textbf{Automatic Room Generation}: 4-digit unique codes
    \item \textbf{Member Tracking}: Tracks users per room
    \item \textbf{Persistent Storage}: Rooms saved to JSON file
    \item \textbf{Service Integration}: All services validate rooms through this service
\end{itemize}

\subsection{Congestion Control Algorithms}

\subsubsection{TCP Tahoe Implementation}

\textbf{Algorithm Steps:}
\begin{enumerate}
    \item \textbf{Initialization}:
    \begin{lstlisting}[language=Python, caption=Tahoe Initialization]
cwnd = 1.0          # Start with 1 MSS
ssthresh = 16.0     # Initial threshold
last_ack = 0        # Last acknowledged sequence
dup_acks = 0        # Duplicate ACK counter
phase = "SLOW_START"
    \end{lstlisting}
    
    \item \textbf{Slow Start Phase}:
    \begin{lstlisting}[language=Python, caption=Slow Start]
if cwnd < ssthresh:
    cwnd += 1.0  # Exponential growth
    print(f"SLOW_START: cwnd={cwnd}")
    \end{lstlisting}
    
    \item \textbf{Congestion Avoidance Phase}:
    \begin{lstlisting}[language=Python, caption=Congestion Avoidance]
else:  # cwnd >= ssthresh
    cwnd += 1.0 / cwnd  # Linear growth
    print(f"CONG_AVOID: cwnd={cwnd}")
    \end{lstlisting}
    
    \item \textbf{Loss Detection (3 Duplicate ACKs)}:
    \begin{lstlisting}[language=Python, caption=Tahoe Fast Retransmit]
if dup_acks == 3:
    ssthresh = max(cwnd / 2.0, 2.0)
    cwnd = 1.0  # Reset to 1 (Tahoe)
    phase = "SLOW_START"
    print(f"LOSS: ssthresh={ssthresh}, cwnd=1")
    retransmit(lost_packet)
    \end{lstlisting}
\end{enumerate}

\subsubsection{TCP Reno Implementation}

\textbf{Fast Recovery Enhancement:}
\begin{enumerate}
    \item \textbf{Fast Retransmit + Fast Recovery}:
    \begin{lstlisting}[language=Python, caption=Reno Fast Recovery]
if dup_acks == 3:
    ssthresh = max(cwnd / 2.0, 2.0)
    cwnd = ssthresh + 3.0  # Fast Recovery (Reno)
    in_fast_recovery = True
    phase = "FAST_RECOVERY"
    print(f"LOSS: ssthresh={ssthresh}, cwnd={cwnd}")
    retransmit(lost_packet)

elif in_fast_recovery:
    cwnd += 1.0  # Inflate window for each dup ACK
    \end{lstlisting}
    
    \item \textbf{Exit Fast Recovery}:
    \begin{lstlisting}[language=Python, caption=Recovery Exit]
if new_ack_received and in_fast_recovery:
    cwnd = ssthresh  # Deflate window
    in_fast_recovery = False
    phase = "CONG_AVOID"
    \end{lstlisting}
\end{enumerate}

\textbf{Key Differences:}
\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Aspect} & \textbf{Tahoe} & \textbf{Reno} \\
\hline
On 3 Dup ACKs & CWND = 1 & CWND = ssthresh + 3 \\
Recovery Phase & Slow Start & Fast Recovery \\
CWND after recovery & 1 MSS & ssthresh MSS \\
Performance & Slower & 30-40\% faster \\
\hline
\end{tabular}
\caption{Tahoe vs Reno Comparison}
\end{table}

Both algorithms are implemented in \texttt{backend/file\_transfer/protocol.py} with real-time metrics visualization.

\subsection{RTT Estimation}

\textbf{Round-Trip Time Measurement:}

\begin{equation}
RTT = T_{ACK} - T_{SEND}
\end{equation}

\textbf{Smoothed RTT (SRTT):}
\begin{equation}
SRTT = (1 - \alpha) \times SRTT + \alpha \times RTT \quad (\alpha = 0.125)
\end{equation}

\textbf{RTT Variance:}
\begin{equation}
RTTVAR = (1 - \beta) \times RTTVAR + \beta \times |SRTT - RTT| \quad (\beta = 0.25)
\end{equation}

\textbf{Retransmission Timeout:}
\begin{equation}
RTO = SRTT + 4 \times RTTVAR
\end{equation}

These metrics are logged per chunk during file transfers and displayed in real-time graphs.

\subsection{Flow Control}

\begin{itemize}
    \item \textbf{Rate Limiting}: Chat server limits users to 5 messages per 2 seconds
    \item \textbf{Buffering}: Servers use buffered I/O for efficient data handling
    \item \textbf{Chunking}: Large data split into 4KB chunks for manageable transmission
    \item \textbf{ACK Mechanism}: Each chunk acknowledged before next transmission
\end{itemize}

\subsection{Threading and Concurrency}

\begin{itemize}
    \item \textbf{Thread-per-Client}: Each server spawns a daemon thread per connection
    \item \textbf{Lock-based Synchronization}: Python locks protect shared data structures
    \item \textbf{Separate I/O Streams}: Read-only and write-only streams to prevent race conditions
    \item \textbf{Background Polling}: Frontend uses threads for real-time updates
\end{itemize}

% ======================== IMPLEMENTATION DETAILS ========================
\section{Implementation Details}

\subsection{Architecture}

\subsubsection{Chat Server}

\textbf{Client Handling Algorithm:}
\begin{enumerate}
    \item \textbf{Connection \& Handshake}:
    \begin{itemize}
        \item Upon accepting a TCP connection, the server spawns a dedicated daemon thread.
        \item It strictly strictly enforces a handshake: the first received message MUST be \texttt{HELLO <username>}. Any other initial command results in immediate disconnection.
        \item The socket-to-username mapping is stored in the thread-safe \texttt{clients} dictionary.
    \end{itemize}

    \item \textbf{Room Participation (JOIN\_ROOM)}:
    \begin{itemize}
        \item The server validates the requested room code by querying the central \textbf{Room Management Service}.
        \item If valid, the client socket is added to the \texttt{rooms} set for that code.
        \item A "SYSTEM joined" message is broadcast to all participants to update their local user lists.
    \end{itemize}

    \item \textbf{Message Processing (MSG)}:
    \begin{itemize}
        \item \textbf{Rate Limiting}: A sliding window algorithm checks the \texttt{msg\_times} deque. If a user exceeds 5 messages in 2.0 seconds, the packet is rejected to prevent spam.
        \item \textbf{ID Generation}: A monotonically increasing \texttt{msg\_id} is generated for the room using an atomic counter.
        \item \textbf{Persistence}: The message is serialized and appended to the \texttt{chat\_history} JSON store.
        \item \textbf{Distribution}: The \texttt{broadcast()} function is invoked to relay the message to all peers in the room.
    \end{itemize}

    \item \textbf{Binary Asset Handling (IMG\_SEND)}:
    \begin{itemize}
        \item \textbf{Size Enforcement}: The server enforces a hard limit of 8MB (Base64) per image to prevent memory exhaustion (\texttt{8 * 1024 * 1024} bytes).
        \item \textbf{Lazy Loading}: Valid images are decoded and saved to the CDN (\texttt{data/cdn}). Only the filename is broadcast, ensuring low-latency delivery of textual messages while clients fetch images asynchronously via \texttt{GET\_IMG}.
    \end{itemize}

    \item \textbf{History Synchronization (HISTORY)}:
    \begin{itemize}
        \item \textbf{Retrieval}: When a client joins, they request history (default 50 messages, capped at 200).
        \item \textbf{Protocol Flow}: The server sends a burst of \texttt{HIST} packets followed by \texttt{HISTORY\_END}, allowing the client to bulk-populate the chat UI without blocking the main event loop.
    \end{itemize}

    \item \textbf{Broadcast Mechanism}:
    \begin{itemize}
        \item \textbf{Target Selection}: The server identifies all active clients in the specific room.
        \item \textbf{Filtering \& Delivery}: The message is relayed to every participant (except the sender to prevent echo). The system uses robust framing and error handling to ensure delivery even if some clients disconnect mid-broadcast.
    \end{itemize}
\end{enumerate}

\textbf{Frontend Integration Algorithm (Client-Side):}
\begin{enumerate}
    \item \textbf{Asynchronous Receiver (TcpChatClient)}:
    \begin{itemize}
        \item A dedicated background thread \texttt{\_recv\_loop} continuously reads lines from the socket.
        \item Incoming messages are pushed into a thread-safe \texttt{queue.Queue}.
        \item This ensures the UI remains responsive and does not freeze while waiting for network I/O.
    \end{itemize}

    \item \textbf{UI Refresh Cycle (chat.py)}:
    \begin{itemize}
        \item \textbf{Auto-Refresh}: \texttt{st\_autorefresh(interval=1000)} triggers a page re-run every second.
        \item \textbf{Message Draining}: On each run, \texttt{client.get\_new\_messages()} drains the background queue.
        \item \textbf{Parsing}: Protocol messages (\texttt{MSG}, \texttt{IMG}, \texttt{HISTORY}) are parsed and added to \texttt{st.session\_state.chat\_log}.
        \item \textbf{Rendering}: The log is rendered using custom CSS bubbles (Green for self, Gray for others).
    \end{itemize}

    \item \textbf{Image Handling}:
    \begin{itemize}
        \item Images are uploaded via Streamlit widget, encoded to base64, and sent via \texttt{IMG\_SEND}.
        \item When receiving an \texttt{IMG} broadcast, the client requests the full data via \texttt{GET\_IMG}.
        \item Received image data is cached in \texttt{st.session\_state.chat\_image\_cache} to prevent redundant network requests.
    \end{itemize}
\end{enumerate}

\subsubsection{File Transfer Server}

\textbf{Server Handling Algorithm (Protocol Logic):}
\begin{enumerate}
    \item \textbf{Session Initialization}:
    \begin{itemize}
        \item When a client initiates a transfer, the server instantiates a \texttt{FileTransferMetrics} tracker.
        \item It logs the chosen algorithm (Reno/Tahoe) and calculates total chunks: $Total = \lceil Size / 4096 \rceil$.
    \end{itemize}

    \item \textbf{Transfer Handshake}:
    \begin{itemize}
        \item \textbf{Upload}: Server receives \texttt{UPLOAD <filename> <size>}.
        \item \textbf{Download}: Server sends \texttt{DOWNLOAD <filename>} header to prepare the client.
    \end{itemize}

    \item \textbf{Transmission Loop (Stop-and-Wait / Sliding Window)}:
    \begin{itemize}
        \item Data is read/written in \textbf{4KB chunks}.
        \item \textbf{Flow Control}: The server monitors in-flight packets. If $(Seq - LastAck) \ge CWND$, the loop pauses (sleeps 1ms) to relieve network pressure.
        \item \textbf{Congestion Control}: On receiving an \texttt{ACK}, the server calculates RTT ($T_{now} - T_{sent}$) and updates the Congestion Window (CWND) using the selected algorithm (Reno/Tahoe).
    \end{itemize}

    \item \textbf{Completion \& Metrics}:
    \begin{itemize}
        \item Upon transferring the final chunk, the connection is closed.
        \item Comprehensive metrics (RTT, CWND, Throughput) are saved to CSV files in \texttt{data/metrics/} for analysis.
    \end{itemize}
\end{enumerate}

\textbf{Frontend Integration Algorithm (Client-Side):}
\begin{enumerate}
    \item \textbf{Synchronous Client Wrapper (SyncroXFileClient)}:
    \begin{itemize}
        \item The frontend uses a blocking TCP client to ensure data integrity during transfers.
        \item It abstracts the socket protocol, handling chunk assembly and ACK transmission automatically.
    \end{itemize}

    \item \textbf{Upload Workflow}:
    \begin{itemize}
        \item Users select files via \texttt{st.file\_uploader}.
        \item \texttt{client.upload\_bytes()} is called within a \texttt{st.spinner} context.
        \item Real-time success/failure feedback is displayed via \texttt{st.success}/\texttt{st.error} toast messages.
    \end{itemize}

    \item \textbf{Two-Stage Download Mechanism}:
    \begin{itemize}
        \item \textbf{Stage 1 (Fetch)}: User clicks \texttt{Prepare}. The client downloads bytes to memory (\texttt{st.session\_state.download\_data}).
        \item \textbf{Stage 2 (Save)}: A confirmed \texttt{dowlnoad\_button} appears, allowing the user to save the binary stream to their local disk.
    \end{itemize}

    \item \textbf{Algorithm Selection}:
    \begin{itemize}
        \item Users toggle between \texttt{Reno} and \texttt{Tahoe} via \texttt{st.radio}.
        \item This choice is passed to the backend during the handshake to dynamically switch congestion control strategies.
    \end{itemize}

    \item \textbf{Metadata Handshake}:
    \begin{itemize}
        \item The client responds with a file header containing the file size (e.g., OK 1048576).
        \item If the header does not start with \texttt{OK}, the transfer is aborted (File Not Found).
    \end{itemize}
    
    \item \textbf{Reception Loop}:
    \begin{itemize}
        \item The server enters a loop initialized with \texttt{received = 0}.
        \item In each iteration, it attempts to read \texttt{min(CHUNK\_SIZE, Remaining\_Bytes)} from the socket.
    \end{itemize}
    
    \item \textbf{Reassembly}:
    \begin{itemize}
        \item Received chunks are immediately written to the target file on disk in binary mode.
        \item The loop terminates only when \texttt{received == file\_size}.
    \end{itemize}
    
    \item \textbf{Verification}:
    \begin{itemize}
        \item A final check usually compares the received byte count against the header size to ensure integrity.
    \end{itemize}
\end{enumerate}

\subsubsection{Collaboration Server}

\textbf{Server Handling Algorithm (State Synchronization):}
\begin{enumerate}
    \item \textbf{Room \& Language Management}:
    \begin{itemize}
        \item The server maintains a dictionary mapping \texttt{room\_id + language} keys (e.g., \texttt{1234\_python}) to document content.
        \item On \texttt{JOIN}, it validates the room with the central management service and serves the current code state to the new user.
    \end{itemize}

    \item \textbf{Atomic Updates (Last-Write-Wins)}:
    \begin{itemize}
        \item \textbf{Locking}: A global \texttt{threading.Lock} serializes all \texttt{SET} operations to prevent race conditions.
        \item \textbf{Persistence}: Updated code is synchronously written to disk (\texttt{data/collab\_docs/}) for crash recovery.
        \item \textbf{Activity Tracking}: The user's timestamp is updated to indicate "typing" status (active if $<3s$ since last edit).
    \end{itemize}

    \item \textbf{Real-Time Broadcasting}:
    \begin{itemize}
        \item After applying a \texttt{SET} command, the \texttt{broadcast\_doc} function relays the new content to all other clients in the room.
        \item \textbf{Echo Prevention}: The sender's socket is explicitly excluded from the broadcast list to avoid overwriting their local editor state.
    \end{itemize}
\end{enumerate}

\textbf{Frontend Integration Algorithm (Client-Side):}
\begin{enumerate}
    \item \textbf{Live Sync Loop}:
    \begin{itemize}
        \item \textbf{Polling}: The client polls the server every 1.5s via \texttt{client.request\_doc()} to ensure eventual consistency.
        \item \textbf{Push Updates}: A background thread listens for incoming \texttt{DOC} packets triggered by other users' edits, updating \texttt{st.session\_state.collab\_editor} in real-time.
    \end{itemize}

    \item \textbf{Auto-Save Mechanism}:
    \begin{itemize}
        \item The UI tracks edits by comparing current editor content with \texttt{collab\_last\_sent}.
        \item If changes are detected and 2.0 seconds have passed since the last keystroke, the client automatically sends a \texttt{SET} command.
    \end{itemize}

    \item \textbf{Remote Execution Integration}:
    \begin{itemize}
        \item When \texttt{Run Code} is clicked, the state is passed to a separate \texttt{TcpExecClient}.
        \item Execution results (stdout/stderr) are JSON-serialized and saved to \texttt{data/exec\_output/} for persistent display across re-runs.
    \end{itemize}
    
    \item \textbf{Atomic Broadcast}:
    \begin{itemize}
        \item While still holding the lock (or immediately after), the \texttt{broadcast\_doc} function is called to push the new state to all \textit{other} connected clients in the room, excluding the originator to prevent cursor jumps.
    \end{itemize}
\end{enumerate}

\subsubsection{Code Execution Server}

\textbf{Server Handling Algorithm (Sandboxed Execution):}
\begin{enumerate}
    \item \textbf{Containerization Strategy}:
    \begin{itemize}
        \item The server uses the Docker SDK to spawn ephemeral containers (python:slim, gcc:latest, openjdk:slim).
        \item \textbf{Isolation}: Each run is isolated with \texttt{network\_disabled=True}, \texttt{mem\_limit="256m"}, and \texttt{nano\_cpus=500000000} (0.5 cores) to prevent resource abuse.
    \end{itemize}

    \item \textbf{Execution Pipeline}:
    \begin{itemize}
        \item \textbf{Preparation}: A temporary directory is mounted to \texttt{/sandbox} inside the container. Code is written to a language-specific entry point (e.g., main.c).
        \item \textbf{Compilation (if applicable)}: For C/C++/Java, a compilation step runs first. Failure here returns early with \texttt{return\_code=1}.
        \item \textbf{Runtime}: The binary or script executes with a 10-second hard timeout. \texttt{stdin} is piped directly to the process.
    \end{itemize}

    \item \textbf{Output Capture}:
    \begin{itemize}
        \item \texttt{stdout} and \texttt{stderr} are captured separately.
        \item The container is strictly removed via \texttt{auto\_remove=False} (managed explicitly) or try-finally blocks to ensure cleanup even after errors.
    \end{itemize}
\end{enumerate}

\textbf{Frontend Integration Algorithm (History \& Visualization):}
\begin{enumerate}
    \item \textbf{History Persistence}:
    \begin{itemize}
        \item All execution results (metrics, output, status) are stored in structured JSON files within \texttt{data/exec\_history/}.
        \item The \texttt{HistoryManager} class provides indexed access by Room, User, and Language.
    \end{itemize}

    \item \textbf{Data Visualization}:
    \begin{itemize}
        \item \textbf{Dashboard}: The Page uses \texttt{st.metric} to show Success Rates and Average Execution Time.
        \item \textbf{Interactive Table}: A \texttt{pandas} DataFrame displays the history log, filterable by room or user.
    \end{itemize}

    \item \textbf{Detailed Inspection}:
    \begin{itemize}
        \item Selecting a row opens a detailed view with tabbed panes for \textbf{Code}, \textbf{Stdout}, \textbf{Stderr}, and \textbf{Input}.
        \item This allows users to debug past runs without re-executing code.
    \end{itemize}
\end{enumerate}



\subsubsection{Application Entry Framework (frontend/streamlit\_app/app.py)}

\textbf{Authentication \& Routing Algorithm:}
\begin{enumerate}
    \item \textbf{Session State Initialization}:
    \begin{itemize}
        \item On script startup, the app initializes persistent state variables: \texttt{username}, \texttt{current\_room}, and \texttt{is\_logged\_in}.
        \item If \texttt{is\_logged\_in} is False, the \texttt{render\_welcome\_page()} function is invoked.
    \end{itemize}

    \item \textbf{Room Management Protocol}:
    \begin{itemize}
        \item \textbf{Creation}: Calls \texttt{room\_mgmt.create\_room(user)}. On success (returning a 4-digit code), the user is automatically logged in and redirected.
        \item \textbf{Joining}: Calls \texttt{room\_mgmt.room\_exists(code)}. If valid, state is updated; otherwise, an error toast is displayed.
    \end{itemize}

    \item \textbf{Feature Navigation}:
    \begin{itemize}
        \item Authenticated users see the \texttt{render\_main\_app()} layout.
        \item Usage of \texttt{st.switch\_page("pages/...")} enables seamless transitions between Chat, Editor, and File Manager modules without losing session context.
    \end{itemize}
\end{enumerate}

\subsubsection{Dashboard \& Analytics System (pages/dashboard\_page.py)}

\textbf{Service Health Monitoring Algorithm:}
\begin{enumerate}
    \item \textbf{Probe Logic}:
    \begin{itemize}
        \item The dashboard iterates through all backend services (Chat:9009, File:9010, Collab:9011, Exec:9012).
        \item It attempts a \texttt{socket.create\_connection((host, port), timeout=0.5)}.
    \end{itemize}
    \item \textbf{Status Indicators}:
    \begin{itemize}
        \item \textbf{Success}: Renders a green "Online" badge with measured latency (ms).
        \item \textbf{Failure}: Renders a red "Offline" badge and displays the \texttt{OSError} details for debugging.
    \end{itemize}
\end{enumerate}

\textbf{Metrics Visualization Engine:}
\begin{enumerate}
    \item \textbf{Data Ingestion}:
    \begin{itemize}
        \item Reads CSV logs from \texttt{data/metrics/} using \texttt{pandas}.
        \item Applies dynamic filters for File Name, Algorithm (Reno/Tahoe), and Transfer Direction.
    \end{itemize}

    \item \textbf{Performance Plotting}:
    \begin{itemize}
        \item \textbf{Comparative View}: Aligns multiple transfer runs to $T=0$ to overlay CWND curves, highlighting the \texttt{Fast Recovery} (Reno) vs \texttt{Slow Start Restart} (Tahoe) behaviors.
        \item \textbf{Throughput Calculation}: Derives transfer speeds ($\sum bytes / \Delta time$) to generate summary statistics tables.
    \end{itemize}
\end{enumerate}

\subsection{Client Libraries}

Each server has a corresponding client library in \texttt{backend/<service>/client.py}:

\begin{itemize}
    \item \textbf{TcpChatClient}: Chat operations
    \item \textbf{TcpFileClient}: File upload/download with congestion control
    \item \textbf{TcpCollabClient}: Document synchronization
    \item \textbf{TcpExecClient}: Code execution requests
\end{itemize}

All clients implement:
\begin{itemize}
    \item Connection management
    \item Protocol command encoding/decoding
    \item Error handling and retries
    \item Graceful disconnection
\end{itemize}

\subsection{Data Persistence}

\begin{itemize}
    \item \textbf{Chat History}: \texttt{data/chat\_history/room\_<code>\_chat.json} and \texttt{user\_<username>\_chat.json}
    \item \textbf{Image CDN}: \texttt{data/cdn/chat\_img\_<room>\_<id>.<ext>}
    \item \textbf{Uploaded Files}: \texttt{data/uploads/<room>/<filename>}
    \item \textbf{Collaborative Docs}: \texttt{data/collab\_docs/<room>\_<lang>.txt}
    \item \textbf{Transfer Metrics}: \texttt{data/metrics/room\_<code>\_file\_metrics.csv}
    \item \textbf{Execution History}: \texttt{data/exec\_history/room\_<code>\_history.json}
    \item \textbf{Execution Output}: \texttt{data/exec\_output/room\_<code>\_latest.json}
    \item \textbf{Room Management}: \texttt{data/rooms/rooms.json}
\end{itemize}



% ======================== RESULT ANALYSIS ========================
\section{Result Analysis}

\subsection{Performance Metrics}

\subsubsection{File Transfer Performance}

\textbf{Experimental Setup:}
\begin{itemize}
    \item \textbf{Test Environment}: Localhost (127.0.0.1), no actual network latency
    \item \textbf{Packet Loss Simulation}: Configurable via \texttt{config.py} (SYNCROX\_LOSS\_PROB)
    \item \textbf{File Sizes Tested}: 100KB, 1MB, 10MB, 50MB
    \item \textbf{Chunk Size}: 4096 bytes (4KB)
    \item \textbf{Initial Parameters}: CWND=1, ssthresh=16
\end{itemize}

\textbf{Tahoe vs Reno Performance Comparison:}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Metric} & \textbf{Tahoe} & \textbf{Reno} & \textbf{Improvement} \\
\hline
Avg RTT (ms) & 15-25 & 12-20 & 16\% faster \\
Max CWND Reached & 32-64 & 48-96 & 50\% higher \\
Transfer Speed (1MB) & 3-4 sec & 2-3 sec & 33\% faster \\
Transfer Speed (10MB) & 28-35 sec & 18-24 sec & 35\% faster \\
Recovery Time & 150-200 ms & 80-120 ms & 40\% faster \\
Loss Retransmissions & 8-12 & 4-6 & 50\% fewer \\
CPU Usage & 2-5\% & 3-6\% & Negligible \\
Memory Usage & 15-20 MB & 16-22 MB & Negligible \\
\hline
\end{tabular}
\caption{Congestion Control Algorithm Performance (10\% Packet Loss)}
\end{table}

\textbf{Detailed Observations:}

\begin{enumerate}
    \item \textbf{Slow Start Behavior}:
    \begin{itemize}
        \item Both algorithms exhibit exponential CWND growth
        \item CWND typically reaches ssthresh in 4-5 RTTs
        \item Smooth transition to congestion avoidance phase
    \end{itemize}
    
    \item \textbf{Loss Recovery Patterns}:
    \begin{itemize}
        \item \textbf{Tahoe}: Sharp drop to CWND=1, complete restart of slow start
        \item \textbf{Reno}: Maintains higher CWND during fast recovery
        \item Reno reduces throughput variance by 40-50\%
    \end{itemize}
    
    \item \textbf{RTT Estimation Accuracy}:
    \begin{itemize}
        \item SRTT converges within 5-8 samples
        \item EWMA smoothing ($\alpha=0.125$) effectively filters noise
        \item RTO rarely causes spurious timeouts (< 1\% of transfers)
    \end{itemize}
    
    \item \textbf{Congestion Avoidance Efficiency}:
    \begin{itemize}
        \item Linear CWND growth (+1/CWND per ACK) works as expected
        \item Steady state CWND oscillates around optimal window size
        \item No premature timeouts or false loss detections
    \end{itemize}
    
    \item \textbf{Scalability}:
    \begin{itemize}
        \item Successfully transferred files up to 100MB
        \item Memory usage remains constant (streaming approach)
        \item Metrics logging has negligible performance impact (< 2\%)
    \end{itemize}
\end{enumerate}

\textbf{CWND Evolution Visualization:}

Metrics CSV files contain detailed logs enabling visualization of:
\begin{itemize}
    \item CWND growth over time (exponential → linear)
    \item RTT variations and SRTT convergence
    \item Loss events and recovery patterns
    \item Throughput vs time graphs
    \item Phase transitions (Slow Start → Congestion Avoidance → Fast Recovery)
\end{itemize}

\subsubsection{Code Execution Performance}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Language} & \textbf{Compilation Time} & \textbf{Execution Time} & \textbf{Memory Usage} \\
\hline
Python & N/A & 50-100 ms & 15-30 MB \\
C & 200-400 ms & 10-20 ms & 5-10 MB \\
C++ & 300-600 ms & 10-25 ms & 8-15 MB \\
Java & 400-800 ms & 100-200 ms & 40-60 MB \\
\hline
\end{tabular}
\caption{Code Execution Performance by Language}
\end{table}

\subsubsection{Real-time Collaboration}

\begin{itemize}
    \item \textbf{Synchronization Latency}: 100-300 ms
    \item \textbf{Concurrent Users Supported}: 10-20 per room
    \item \textbf{Document Size Limit}: Tested up to 100KB
    \item \textbf{Conflict Resolution}: Last-write-wins (deterministic)
\end{itemize}

\subsection{System Reliability}

\textbf{Stress Testing Results:}
\begin{itemize}
    \item \textbf{Chat Server}: Handled 50 concurrent connections reliably
    \item \textbf{File Server}: Transferred 100MB+ files without issues
    \item \textbf{Code Execution}: Successfully sandboxed malicious code attempts
    \item \textbf{Memory Leaks}: None detected over 24-hour runtime
    \item \textbf{Thread Safety}: No race conditions in 1000+ operations
\end{itemize}

\subsection{User Experience}

\textbf{Features Successfully Demonstrated:}
\begin{enumerate}
    \item Real-time chat with instant message delivery
    \item Live code editing with sub-second synchronization
    \item File uploads with visual congestion control metrics
    \item Secure code execution across multiple languages
    \item Intuitive dashboard with network analytics
\end{enumerate}

\textbf{User Feedback (from testing):}
\begin{itemize}
    \item Modern, clean interface praised by users
    \item Real-time metrics visualization highly educational
    \item Code execution sandbox provides peace of mind
    \item Room-based isolation effective for team separation
    \item Auto-refresh features reduce manual interaction
\end{itemize}

\subsection{Educational Value}

\textbf{Networking Concepts Demonstrated:}
\begin{itemize}
    \item Custom protocol design and implementation
    \item Congestion control algorithm behavior visualization
    \item RTT measurement and smoothing techniques
    \item Flow control and rate limiting
    \item Multi-threaded server architecture
    \item Socket programming best practices
\end{itemize}

The project provides hands-on experience with theoretical concepts taught in networking courses, making it an excellent educational resource.

% ======================== USER INTERFACE SHOWCASE ========================
\subsection{Major Input/Output Visualizations}

The following screenshots demonstrate the key functional modules of the SyncroX platform, highlighting the user interface design and operational workflows.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{chat_interface.png}
\caption{Chat Interface: Real-time messaging module featuring user differentiation, message timestamps, image attachments, and emoji support.}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{code_editior.PNG}
\caption{Collaborative Code Editor: A syntax-highlighted editor (CPP shown) with live multi-user synchronization and language selection support.}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{file_transfer.png}
\caption{File Transfer Manager: Interface for uploading files with selectable congestion control algorithms (Reno/Tahoe) and monitoring download progress.}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{graph.png}
\caption{Network Metrics Visualization: Real-time graphs plotting Congestion Window (CWND) size and Round-Trip Time (RTT) to analyze protocol behavior.}
\end{figure}

% ======================== SUMMARY OF THE PROJECT ========================
\section{Summary of the Project}

SyncroX successfully demonstrates a production-grade collaborative platform built entirely using Python networking libraries and modern containerization techniques. The project achieves its primary goals of implementing advanced networking concepts—specifically custom Application Layer protocols and Congestion Control algorithms—while providing a seamless, real-time user experience.

\subsection{Key Achievements}

\begin{enumerate}
    \item \textbf{Custom Protocol Suite}: Designed and implemented four distinct application-layer protocols handling textual chat, binary file streaming, JSON-based state synchronization, and remote execution commands.
    
    \item \textbf{Congestion Control Implementation}: Successfully implemented and specialized the \textbf{TCP Tahoe} and \textbf{TCP Reno} algorithms over UDP, providing a practical testbed for analyzing "Slow Start", "Congestion Avoidance", and "Fast Recovery" phases in real-time.
    
    \item \textbf{Sandboxed Code Execution}: Integrated a secure, Docker-based pipeline \texttt{(backend/code\_exec)} capable of compiling and running untrusted C, C++, Java, and Python code with strict resource isolation.
    
    \item \textbf{Atomic State Synchronization}: Achieved conflict-free real-time collaboration using a centralized "Last-Write-Wins" state machine with broadcast damping to prevent echo loops.
    
    \item \textbf{Educational Observability}: Built a comprehensive Dashboard and Metrics visualization system that exposes internal network states (CWND, RTT, Bandwidth) to the user, bridging the gap between theory and practice.
\end{enumerate}

\subsection{Technical Highlights}

\begin{itemize}
    \item \textbf{Microservices Architecture}:
    \begin{itemize}
        \item \textbf{Chat Service} (TCP 9009): Async streaming with history playback.
        \item \textbf{File Transfer Service} (TCP 9010 / UDP 9011): Hybrid reliability with configurable congestion control.
        \item \textbf{Collaboration Service} (TCP 9011): Low-latency state sync.
        \item \textbf{Execution Service} (TCP 9012): Ephemeral container orchestration.
        \item \textbf{Room Management} (TCP 9013): Centralized session authority.
    \end{itemize}
    
    \item \textbf{Advanced Reliability Features}: 
    \begin{itemize}
        \item \textbf{RTO Estimation}: Jacob's Algorithm implementation via EWMA ($\alpha=0.125, \beta=0.25$).
        \item \textbf{Binary Safety}: Base64 encoding for transparent handling of images and executables.
        \item \textbf{Thread Safety}: Granular locking (`threading.Lock`) ensuring data integrity across concurrent client requests.
    \end{itemize}
\end{itemize}

% ======================== LIMITATIONS AND FUTURE PLANS ========================
\section{Limitations and Future Plans}

\subsection{Current Limitations}

\begin{enumerate}
    \item \textbf{Scalability Constraints}:
    \begin{itemize}
        \item \textbf{Vertical Scaling Only}: The current architecture relies on in-memory Python dictionaries (`rooms`, `clients`) and global thread locks (GIL), limiting performance to a single server instance.
        \item \textbf{State Volatility}: While logs are persisted to disk, the active room state is lost upon server restart.
    \end{itemize}
    
    \item \textbf{Database Limitations}:
    \begin{itemize}
        \item \textbf{JSON/CSV Storage}: Data is stored in flat files, which hinders complex querying (e.g., "search chat history by keyword") and lacks ACID transaction guarantees.
    \end{itemize}
    
    \item \textbf{Collaboration Conflict Resolution}:
    \begin{itemize}
        \item \textbf{Last-Write-Wins (LWW)}: This simple strategy effectively manages state but can overwrite concurrent edits if they arrive within the same millisecond. It lacks the sophistication of Operational Transformation (OT) or CRDTs.
    \end{itemize}
    
    \item \textbf{Security Gaps}:
    \begin{itemize}
        \item \textbf{No Encryption}: Traffic is sent in plaintext, making it vulnerable to sniffing on untrusted networks.
        \item \textbf{Basic Auth}: Authentication implies only a username; there are no passwords or JWT tokens.
    \end{itemize}
\end{enumerate}

\subsection{Future Enhancements}

\subsubsection{Short-term Improvements (v2.0)}
\begin{itemize}
    \item \textbf{Persistence Layer}: Migrate from JSON/CSV to \textbf{SQLite} or \textbf{PostgreSQL} to enable relational queries and robust data integrity.
    \item \textbf{Operational Transformation}: Implement a basic OT algorithm (e.g., Jupiter) to handle concurrent text edits more gracefully than LWW.
    \item \textbf{Production Deployment}: Containerize the entire backend stack with \textbf{Docker Compose} for one-command deployment.
\end{itemize}

\subsubsection{Long-term Roadmap (v3.0)}
\begin{itemize}
    \item \textbf{Distributed State}: Replace in-memory dictionaries with \textbf{Redis} to allow horizontal scaling across multiple server nodes.
    \item \textbf{End-to-End Encryption}: Wrap all TCP sockets in \textbf{SSL/TLS} contexts to secure data in transit.
    \item \textbf{Advanced Execution Environment}: Support for compiled project structures (Makefiles) and long-running services (web servers) within the sandbox.
\end{itemize}



% ======================== CONCLUSION ========================
\section{Conclusion}

SyncroX represents a comprehensive exploration of networking principles through practical implementation. It demonstrates that complex networking systems can be built using foundational principles and modern tools. The project proves that theoretical concepts like congestion control, RTT estimation, and protocol design are not just academic exercises—they are essential building blocks for real-world distributed systems.
\end{document}
